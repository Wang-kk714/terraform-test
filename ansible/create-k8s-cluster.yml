---
# Kubernetes Cluster Creation Playbook
# Purpose: Automate Kubernetes cluster creation
# Usage: ansible-playbook -i inventory.ini create-k8s-cluster.yml

- name: Prepare all nodes environment
  hosts: k8s_cluster
  gather_facts: yes
  become: yes
  become_method: sudo

  tasks:
    - name: Check OS version
      debug:
        msg: "OS: {{ ansible_distribution }} {{ ansible_distribution_version }}"

    - name: Disable swap
      shell: |
        swapoff -a
        sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab
      changed_when: true

    - name: Load required kernel modules
      modprobe:
        name: "{{ item }}"
        state: present
      loop:
        - overlay
        - br_netfilter
      changed_when: false

    - name: Configure kernel parameters
      sysctl:
        name: "{{ item.key }}"
        value: "{{ item.value }}"
        state: present
        sysctl_set: yes
        reload: yes
      loop:
        - { key: 'net.bridge.bridge-nf-call-iptables', value: '1' }
        - { key: 'net.bridge.bridge-nf-call-ip6tables', value: '1' }
        - { key: 'net.ipv4.ip_forward', value: '1' }

    - name: Ensure kernel modules are loaded at boot
      lineinfile:
        path: /etc/modules-load.d/k8s.conf
        line: "{{ item }}"
        create: yes
      loop:
        - overlay
        - br_netfilter

    - name: Ensure sysctl configuration is persistent
      lineinfile:
        path: /etc/sysctl.d/k8s.conf
        line: "{{ item.key }}={{ item.value }}"
        create: yes
      loop:
        - { key: 'net.bridge.bridge-nf-call-iptables', value: '1' }
        - { key: 'net.bridge.bridge-nf-call-ip6tables', value: '1' }
        - { key: 'net.ipv4.ip_forward', value: '1' }

- name: Install container runtime (containerd)
  hosts: k8s_cluster
  become: yes
  become_method: sudo

  tasks:
    - name: Install required tools
      package:
        name:
          - apt-transport-https
          - ca-certificates
          - curl
          - gnupg
          - lsb-release
        state: present
      when: ansible_pkg_mgr == 'apt'

    - name: Create keyrings directory for Docker
      file:
        path: /etc/apt/keyrings
        state: directory
        mode: '0755'
      when: ansible_pkg_mgr == 'apt'

    - name: Import Docker GPG key properly
      shell: |
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
      when: ansible_pkg_mgr == 'apt'
      args:
        creates: /etc/apt/keyrings/docker.gpg

    - name: Remove existing Docker repository if any
      apt_repository:
        repo: "deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable"
        state: absent
      when: ansible_pkg_mgr == 'apt'
      ignore_errors: yes

    - name: Add Docker repository
      apt_repository:
        repo: "deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable"
        state: present
        filename: docker
      when: ansible_pkg_mgr == 'apt'

    - name: Update apt cache after adding Docker repository
      apt:
        update_cache: yes
      when: ansible_pkg_mgr == 'apt'

    - name: Install containerd
      package:
        name: containerd.io
        state: present
        update_cache: yes

    - name: Configure containerd
      copy:
        content: |
          [plugins."io.containerd.grpc.v1.cri".registry.mirrors."docker.io"]
            endpoint = ["https://docker.mirrors.ustc.edu.cn"]
          [plugins."io.containerd.grpc.v1.cri".registry.mirrors."registry.aliyuncs.com"]
            endpoint = ["https://registry.aliyuncs.com"]
        dest: /etc/containerd/config.toml
        mode: '0644'
      notify: restart containerd

    - name: Enable and start containerd
      systemd:
        name: containerd
        enabled: yes
        state: started

  handlers:
    - name: restart containerd
      systemd:
        name: containerd
        state: restarted

- name: Install Kubernetes components
  hosts: k8s_cluster
  become: yes
  become_method: sudo

  tasks:
    - name: Create keyrings directory for Kubernetes
      file:
        path: /etc/apt/keyrings
        state: directory
        mode: '0755'
      when: ansible_pkg_mgr == 'apt'

    - name: Remove existing Kubernetes repository if any
      apt_repository:
        repo: "deb https://pkgs.k8s.io/core:/stable:/v1.28/deb/ /"
        state: absent
      when: ansible_pkg_mgr == 'apt'
      ignore_errors: yes

    - name: Remove old Kubernetes GPG key if exists
      file:
        path: /etc/apt/keyrings/kubernetes-apt-keyring.gpg
        state: absent
      when: ansible_pkg_mgr == 'apt'
      ignore_errors: yes

    - name: Download and import Kubernetes GPG key
      shell: |
        curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.28/deb/Release.key | gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
        chmod 644 /etc/apt/keyrings/kubernetes-apt-keyring.gpg
      when: ansible_pkg_mgr == 'apt'

    - name: Add Kubernetes repository
      apt_repository:
        repo: "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.28/deb/ /"
        state: present
        filename: kubernetes
      when: ansible_pkg_mgr == 'apt'

    - name: Update apt cache after adding Kubernetes repository
      apt:
        update_cache: yes
      when: ansible_pkg_mgr == 'apt'

    - name: Install kubeadm, kubelet, kubectl
      package:
        name:
          - kubelet
          - kubeadm
          - kubectl
        state: present
        update_cache: yes

    - name: Hold kubelet, kubeadm, kubectl versions (prevent auto-update)
      dpkg_selections:
        name: "{{ item }}"
        selection: hold
      loop:
        - kubelet
        - kubeadm
        - kubectl
      when: ansible_pkg_mgr == 'apt'

    - name: Enable kubelet service
      systemd:
        name: kubelet
        enabled: yes
        state: started

- name: Initialize Master node
  hosts: k8s_master
  become: yes
  become_method: sudo
  gather_facts: yes

  tasks:
    - name: Get Master node IP
      set_fact:
        master_ip: "{{ ansible_host | default(ansible_default_ipv4.address) }}"

    - name: Initialize Kubernetes cluster
      command: >
        kubeadm init
        --apiserver-advertise-address={{ master_ip }}
        --pod-network-cidr=10.244.0.0/16
        --image-repository=registry.aliyuncs.com/google_containers
        --kubernetes-version=stable
      register: kubeadm_init
      changed_when: "'Your Kubernetes control-plane has initialized' in kubeadm_init.stdout"

    - name: Create .kube directory
      file:
        path: /home/{{ ansible_user }}/.kube
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'

    - name: Copy kubeconfig file
      copy:
        src: /etc/kubernetes/admin.conf
        dest: /home/{{ ansible_user }}/.kube/config
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'
        remote_src: yes
      when: kubeadm_init.changed

    - name: Extract join command
      shell: kubeadm token create --print-join-command
      register: join_command
      changed_when: false
      when: kubeadm_init.changed

    - name: Display join command
      debug:
        msg: "Worker node join command: {{ join_command.stdout }}"

    - name: Save join command to file
      copy:
        content: "{{ join_command.stdout }}\n"
        dest: /tmp/kubeadm-join-command.sh
        mode: '0755'
      when: join_command.stdout is defined

- name: Install network plugin (Calico)
  hosts: k8s_master
  become: yes
  become_method: sudo

  tasks:
    - name: Install Calico network plugin
      shell: |
        export KUBECONFIG=/etc/kubernetes/admin.conf
        kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/calico.yaml
      args:
        creates: /tmp/calico-installed
      register: calico_install

    - name: Mark Calico as installed
      file:
        path: /tmp/calico-installed
        state: touch
      when: calico_install.changed

    - name: Wait for Calico Pods to be ready
      shell: |
        export KUBECONFIG=/etc/kubernetes/admin.conf
        kubectl wait --for=condition=ready pod --all -n kube-system --timeout=300s
      when: calico_install.changed

- name: Join Worker nodes to cluster
  hosts: k8s_workers
  become: yes
  become_method: sudo

  tasks:
    - name: Get join command from Master node
      slurp:
        src: /tmp/kubeadm-join-command.sh
      delegate_to: "{{ groups['k8s_master'][0] }}"
      register: join_command_file
      failed_when: false

    - name: Get join command directly from Master node (fallback method)
      shell: kubeadm token create --print-join-command
      delegate_to: "{{ groups['k8s_master'][0] }}"
      become: yes
      register: join_command_direct
      when: join_command_file.content is not defined or join_command_file.content == ""
      failed_when: false

    - name: Initialize join_result variable
      set_fact:
        join_result: { "rc": -1, "stdout": "", "stderr": "Join command not found" }

    - name: Execute join command (from file)
      shell: "{{ join_command_file.content | b64decode | trim }}"
      when: join_command_file.content is defined and join_command_file.content != ""
      register: join_result
      failed_when: "'This node has joined the cluster' not in join_result.stdout"

    - name: Execute join command (direct)
      shell: "{{ join_command_direct.stdout }}"
      when: (join_command_file.content is not defined or join_command_file.content == "") and (join_command_direct.stdout is defined and join_command_direct.stdout != "")
      register: join_result
      failed_when: "'This node has joined the cluster' not in join_result.stdout"

    - name: Display join result
      debug:
        msg: "Node {{ inventory_hostname }} joined cluster: {{ 'Success' if (join_result.rc | default(-1) == 0) else 'Failed' }}"

- name: Verify cluster status
  hosts: k8s_master
  become: yes
  become_method: sudo

  tasks:
    - name: Check node status
      shell: |
        export KUBECONFIG=/etc/kubernetes/admin.conf
        kubectl get nodes
      register: node_status

    - name: Display node status
      debug:
        var: node_status.stdout_lines

    - name: Check all Pods status
      shell: |
        export KUBECONFIG=/etc/kubernetes/admin.conf
        kubectl get pods --all-namespaces
      register: pod_status

    - name: Display Pods status
      debug:
        var: pod_status.stdout_lines

